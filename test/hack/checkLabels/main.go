package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	promv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	alertConfig "github.com/prometheus/alertmanager/config"
	"sigs.k8s.io/yaml"
)

/*
* This program detects errors in inhibitions configuration.
* It verifies and reports any missing elements from the following:
* - target labels (`cancel_if_*`) are actually defined in some `target_matchers` Inhibition definition
* - source labels from `source_matchers` Inhibition definition are defined by some Alerts
*
* In order for an alert to be inhibited we need 3 elements :
* - an Alert with some source labels
* - an Inhibition definition mapping source labels to target labels
* - an Alert with some target labels
*
* example:
* - Alert `InhibitionOutsideWorkingHours` has label `outside_working_hours=true`
* - Inhibition definition says `source_matchers: [outside_working_hours=true], target_matchers: [cancel_if_outside_working_hours=true]` (leaving out the equal part to simplify)
* - Alert `MyAlert` has label `cancel_if_outside_working_hours=true`
*
* GLOSSARY
* https://github.com/giantswarm/prometheus-rules/#inhibitions
* am_sourceMatchers and am_targetMatchers are the labels defined in the alertmanager config file
* sourceLabels are the labels defined in the alerting rules from which originate the inhibitions
* 	--> For example, 'outside_working_hours' is the source label for the 'cancel_if_outside_working_hours' inhibition label
* cancelLabels is another name for the inhibition labels (for example : 'cancel_if_outside_working_hours')
**/
const output = "../output/helm-chart"
const alertRulesPath = "alerting-rules"

// Parse the alertmanager config file
func parseInhibitionFile(fileName string) (alertConfig.Config, error) {
	var inhibitions alertConfig.Config

	f, err := os.ReadFile(fileName)
	if err != nil {
		return alertConfig.Config{}, err
	}

	parseErr := yaml.Unmarshal(f, &inhibitions)
	if parseErr != nil {
		return alertConfig.Config{}, err
	}

	return inhibitions, nil
}

// Return either the list of target or a specific source label from the alertmanager config file
// If no target is specified in the function's parameters, the function will return the targetMatchers list from the config and an empty list of sourceMatchers
func getTargetsAndSources(config alertConfig.Config, target string) ([]string, string) {
	var am_targetMatchers []string
	var am_sourceMatchers []string

	for _, match := range config.InhibitRules {
		for _, targetLabel := range match.TargetMatchers {
			if target == "" {
				am_targetMatchers = addIfNotPresent(am_targetMatchers, targetLabel.Name)
			} else if targetLabel.Name == target {
				for _, source := range match.SourceMatchers {
					// Checking the source's value as all inhibition labels are booleans but not all sourceMatchers are (clusterid for example)
					if source.Value == "true" || source.Value == "false" {
						am_sourceMatchers = append(am_sourceMatchers, source.Name)
					}
				}
			}
		}
	}

	// To avoid go panicking
	if len(am_sourceMatchers) == 0 {
		return am_targetMatchers, ""
	}

	// return am_targetMatchers, am_sourceMatchers
	return am_targetMatchers, am_sourceMatchers[0]
}

func parseYaml(data []byte) (promv1.PrometheusRule, error) {
	var p promv1.PrometheusRule

	err := yaml.Unmarshal(data, &p)
	if err != nil {
		return promv1.PrometheusRule{}, err
	}

	return p, nil
}

func addIfNotPresent(array []string, newValue string) []string {
	for _, label := range array {
		if label == newValue {
			return array
		}
	}

	array = append(array, newValue)

	return array
}

func getLabels(ruleList []promv1.PrometheusRule, matcher string) []string {
	var labelList []string

	for _, p := range ruleList {
		for _, group := range p.Spec.Groups {
			for _, rule := range group.Rules {
				for key := range rule.Labels {
					// When the targetted label is found, add it to the list if not already present in it
					// There's an exception for `cancel_if_outside_working_hours` as it's managed in alertmanager config
					if matcher == "cancel_if_" && key != "cancel_if_outside_working_hours" && strings.HasPrefix(key, matcher) {
						labelList = addIfNotPresent(labelList, key)
					} else if key == matcher {
						labelList = addIfNotPresent(labelList, matcher)
					}
				}
			}
		}
	}

	return labelList
}

func getMissingLabels() ([]string, []string, error) {
	var rulesList []promv1.PrometheusRule
	var missingSourceLabels []string
	var missingTargetMatchers []string
	alertConf, err := parseInhibitionFile("alertmanager.yaml")
	if err != nil {
		return nil, nil, err
	}

	target_output, err := filepath.Abs(output)
	if err != nil {
		return nil, nil, err
	}

	// We iterates over all the PrometheusRule generated by helm in test/hack/output/helm-chart
	err = filepath.Walk(target_output, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			fmt.Println(err)
			return err
		}
		if !info.IsDir() {
			// If the current item is a file, read its content
			f, err := os.ReadFile(path)
			if err != nil {
				return err
			}

			// Parse the file content...
			p, err := parseYaml(f)
			if err != nil {
				return err
			}

			// .. And adds the resulting rule to the prometheus-rules list
			rulesList = append(rulesList, p)
		}
		return nil
	})

	if err != nil {
		fmt.Println(err)
		return nil, nil, err
	}

	// Get the list of labels with prefix "cancel_if_"
	cancelLabels := getLabels(rulesList, "cancel_if_")
	targetLabels, _ := getTargetsAndSources(alertConf, "")

	for _, cancelLabel := range cancelLabels {
		var i = 0

		for _, targetLabel := range targetLabels {
			if cancelLabel == targetLabel {
				i++

				// Limitation: we check the first source matchers found as we expect at least one source matcher for each target matcher. But there could be multiple and this part could be improved.
				_, source := getTargetsAndSources(alertConf, cancelLabel)
				var originLabelList = getLabels(rulesList, source)

				if len(originLabelList) == 0 {
					missingSourceLabels = addIfNotPresent(missingSourceLabels, source)
				}
				break
			}
		}

		if i == 0 {
			missingTargetMatchers = append(missingTargetMatchers, cancelLabel)
		}
	}

	return missingSourceLabels, missingTargetMatchers, nil
}

func main() {
	missingSourceLabel, missingTargetMatchers, err := getMissingLabels()
	if err != nil {
		log.Fatal(err)
	}

	if len(missingTargetMatchers) > 0 || len(missingSourceLabel) > 0 {
		if len(missingTargetMatchers) > 0 {
			fmt.Println("## Found %d missing target labels\n## Those labels should be defined in source_matchers field in alertmanager's inhibit_rule config.", len(missingTargetMatchers))
			for _, label := range missingTargetMatchers {
				fmt.Println(label)
			}
		}
		if len(missingSourceLabel) > 0 {
			fmt.Printf("## Found %d missing source labels\n## Those labels should be defined by an alert in %q\n", len(missingSourceLabel), alertRulesPath)
			for _, label := range missingSourceLabel {
				fmt.Println(label)
			}
		}

		os.Exit(1)
	} else {
		os.Exit(0)
	}
}
